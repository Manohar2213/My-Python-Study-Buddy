Python Dictionaries

A dictionary is a collection of key-value pairs that is ordered (as of Python 3.7+), changeable, and does not allow duplicate keys. Dictionaries are used to store data values like a map.

Creating Dictionaries:
Dictionaries are created using curly braces {} or the dict() constructor.

Examples:
# Empty dictionary
my_dict = {}
# or
my_dict = dict()

# Dictionary with items
person = {
    "name": "Alice",
    "age": 30,
    "city": "New York"
}

# Dictionary with different data types
mixed_dict = {
    "name": "Bob",
    "age": 25,
    "scores": [85, 90, 78],
    "is_student": True
}

Accessing Dictionary Items:
Use keys to access values.

person = {"name": "Alice", "age": 30, "city": "New York"}

# Access by key
print(person["name"])     # Output: Alice
print(person["age"])      # Output: 30

# Using get() method (safer - returns None if key doesn't exist)
print(person.get("name"))        # Output: Alice
print(person.get("country"))     # Output: None
print(person.get("country", "USA"))  # Output: USA (default value)

Modifying Dictionaries:
Dictionaries are mutable - you can change, add, or remove items.

# Change existing value
person = {"name": "Alice", "age": 30}
person["age"] = 31
print(person)  # Output: {"name": "Alice", "age": 31}

# Add new key-value pair
person["city"] = "Boston"
print(person)  # Output: {"name": "Alice", "age": 31, "city": "Boston"}

# Update multiple items
person.update({"age": 32, "job": "Engineer"})
print(person)  # Output: {"name": "Alice", "age": 32, "city": "Boston", "job": "Engineer"}

Removing Items from Dictionaries:

1. pop() - removes item with specified key
person = {"name": "Alice", "age": 30, "city": "New York"}
removed_age = person.pop("age")
print(person)      # Output: {"name": "Alice", "city": "New York"}
print(removed_age) # Output: 30

2. popitem() - removes last inserted key-value pair
last_item = person.popitem()
print(person)    # Output: {"name": "Alice"}
print(last_item) # Output: ("city", "New York")

3. del - deletes item with specified key
person = {"name": "Alice", "age": 30, "city": "New York"}
del person["age"]
print(person)  # Output: {"name": "Alice", "city": "New York"}

4. clear() - empties the dictionary
person.clear()
print(person)  # Output: {}

Dictionary Methods:

1. keys() - returns all keys
person = {"name": "Alice", "age": 30, "city": "New York"}
keys = person.keys()
print(keys)  # Output: dict_keys(["name", "age", "city"])
print(list(keys))  # Output: ["name", "age", "city"]

2. values() - returns all values
values = person.values()
print(values)  # Output: dict_values(["Alice", 30, "New York"])
print(list(values))  # Output: ["Alice", 30, "New York"]

3. items() - returns key-value pairs as tuples
items = person.items()
print(items)  # Output: dict_items([("name", "Alice"), ("age", 30), ("city", "New York")])
print(list(items))  # Output: [("name", "Alice"), ("age", 30), ("city", "New York")]

4. copy() - creates a copy of the dictionary
original = {"a": 1, "b": 2}
copy_dict = original.copy()
print(copy_dict)  # Output: {"a": 1, "b": 2}

Checking if Key Exists:
Use 'in' keyword to check if key exists in dictionary.

person = {"name": "Alice", "age": 30}
if "name" in person:
    print("Name exists in dictionary")

if "salary" not in person:
    print("Salary not found in dictionary")

Looping Through Dictionaries:

1. Loop through keys
person = {"name": "Alice", "age": 30, "city": "New York"}
for key in person:
    print(key)

# Or explicitly
for key in person.keys():
    print(key)

2. Loop through values
for value in person.values():
    print(value)

3. Loop through key-value pairs
for key, value in person.items():
    print(f"{key}: {value}")

Nested Dictionaries:
Dictionaries can contain other dictionaries.

students = {
    "student1": {
        "name": "Alice",
        "age": 20,
        "grades": {"math": 85, "science": 90}
    },
    "student2": {
        "name": "Bob",
        "age": 21,
        "grades": {"math": 78, "science": 88}
    }
}

# Accessing nested values
print(students["student1"]["name"])  # Output: Alice
print(students["student1"]["grades"]["math"])  # Output: 85

Dictionary Comprehensions:
Create dictionaries using comprehension syntax.

# Basic dictionary comprehension
numbers = [1, 2, 3, 4, 5]
squares = {x: x**2 for x in numbers}
print(squares)  # Output: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# With condition
even_squares = {x: x**2 for x in numbers if x % 2 == 0}
print(even_squares)  # Output: {2: 4, 4: 16}

# From two lists
names = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 35]
people = {name: age for name, age in zip(names, ages)}
print(people)  # Output: {"Alice": 25, "Bob": 30, "Charlie": 35}

Common Dictionary Operations:

1. Get length
person = {"name": "Alice", "age": 30, "city": "New York"}
print(len(person))  # Output: 3

2. Merge dictionaries (Python 3.9+)
dict1 = {"a": 1, "b": 2}
dict2 = {"c": 3, "d": 4}
merged = dict1 | dict2
print(merged)  # Output: {"a": 1, "b": 2, "c": 3, "d": 4}

# Or using update()
dict1.update(dict2)
print(dict1)  # Output: {"a": 1, "b": 2, "c": 3, "d": 4}

3. Default values with setdefault()
person = {"name": "Alice"}
person.setdefault("age", 25)  # Adds age if it doesn't exist
print(person)  # Output: {"name": "Alice", "age": 25}

person.setdefault("age", 30)  # Doesn't change existing value
print(person)  # Output: {"name": "Alice", "age": 25}

Dictionary vs Other Data Types:
- Dictionaries are ordered (Python 3.7+)
- Dictionaries are mutable (can be changed)
- Dictionary keys must be unique
- Dictionary keys must be immutable (strings, numbers, tuples)
- Dictionaries use curly braces {}
- Dictionaries are accessed by key, not index

Common Use Cases:
1. Storing related information (like a record)
2. Counting occurrences
3. Caching/memoization
4. Configuration settings
5. Mapping relationships

Example - Counting words:
text = "hello world hello python world"
word_count = {}
for word in text.split():
    if word in word_count:
        word_count[word] += 1
    else:
        word_count[word] = 1
print(word_count)  # Output: {"hello": 2, "world": 2, "python": 1}

# Or using get()
word_count = {}
for word in text.split():
    word_count[word] = word_count.get(word, 0) + 1

# Or using setdefault()
word_count = {}
for word in text.split():
    word_count.setdefault(word, 0)
    word_count[word] += 1

Best Practices:
1. Use meaningful key names
2. Check if key exists before accessing (use get() or 'in')
3. Use dictionary comprehensions for simple transformations
4. Be careful with mutable values in dictionaries
5. Consider using defaultdict for complex default behaviors